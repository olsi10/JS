<script>
	//원시자료형 7개를 다 빼면 객체
	//숫자, 문자, 불리안, 널, 언디파인드, 심볼, 리미티드, 객체
	//함수의 자료형 ? = 객체
	//배열의 자료형 ? = 객체

	//pop은 맨 뒤 요소 제거
	//push 맨 뒤 요소 추가
	//shift 배열 맨 앞 요소 제거 & 반환
	//unshift 배열 맨 앞 요소 추가

	//가변 = 바뀌는 수

	//배열으 크기가 늘어나고 중간에 공백이 생기면 undefined
	//그럴 땐 push로 맨 뒤에 추가

	//for ... in => 왼쪽이 속성값을 받을 변수 오른쪽 객체
	//for ... in - 모든 프로퍼티(속성)을 순회함

	//for of => 배열 요소를 대상으로 반복 작업

	/*let obj = { name : "John", age = 20 };
	for(let prop in obj) {
		console.log(type of (prop), prop);
	}

	//요소를 순회
	//하지만 배열은 인덱스 번호를 가짐
	let arr = ["Hello", "Java"];
	for (let item of arr) { //
		console.log(item);
	}

	let arr = ["Hello", "Java"];
	for (let item in arr) { //item은 0, 1, 2 나옴
		//뒤에 mIRIM이 추가 되면 0, 1, 2, 3 나옴
		console.log(item);
	}*/

	/*let matrix = [
		[1, 2, 3],
		[4, 5, 6],
		[7, 8, 9]
		];
		// 중심에 있는 요소 5 출력
		alert( matrix[1][1] );
		// Q) 9를 출력하기 위한 코드 작성
		alrt (maritx[2][2]); */

	// 인덱스 정보까지 더해서 출력해주는 좀 더 정교한 코드
	/*["Bilbo", "Gandalf", "Nazgul"].forEach((item, index, array) => {
	alert(`${item} is at index ${index} in ${array}`);
	});*/
	//for of 를 쓰고 싶을 때엔 값에 관심이 있을 때
	//for문에 값과 인덱스값이 필요할 때 each가 필요함
	//어짜피 결과는 같지만 필요한 것이 다를 때 구분하여 사용

	//콘솔로 출력확인을 간단하게 할 수 있음
	//console.log(item, index, array);

	/*let users = [
		{id: 1, name: "John"},
		{id: 2, name: "Pete"},
		{id: 3, name: "Mary"}
];

	let names = user.map(user => ...);
console.log(names);*/

	// Q1) 영화 제목 길이 오름차순으로 정렬
	/*let movies = ["누구를 위하여 종은 울리나", "기생충", "패왕별희", "북북서로 진로를 돌려라", "시"];

	movies.sort((m1, m2) => m1.length - m2.length);
	console.log(movies);

	// Q2) 학생 점수 내림차순으로 정렬
	let students = [{ name: "김민영", score: 100 }, { name: "밧선쥐", score: 80 }, {
	name: "윤싕현", score: 90 }]

	students.sort((s1, s2) => s2.score - s1.score);
	console.log(students);*/

	/*let styles = ["Jazz", "Blues"];

	styles.push("Rock-n-Roll");									//push 맨 뒤 요소 추가
	
	//Jazz, Blues, Rock-n-Roll

	styles.splice(1, 1, "Clasic");

	alert(styles.shift());									//shift 배열 맨 앞 요소(Jazz) 제거 & 반환
	
	styles.unshift("Rap", "Reggae");*/							//unshift 배열 맨 앞 요소 추가

	//((styles.length - 1) / 2)]  정중앙 구하는 법

	//slice(start, end) – start부터 end 바로 앞까지의 요소를 복사해 새로운 배열을 만듦
	//

	/*function copySorted(arr) {
	  let ret = [];

	  // 1. a의 내용을 ret에 복사
	  for(let item of arr) {
	  	ret.push(item);
	  }

	  // 2. ret의 내용을 정렬 (문자열의 length 길이 오름차)
	  ret.sort((a, b) => a.length - b.length);
	  }

	  return ret;

	let arr = ["HTML", "JavaScript", "CSS"];

	let sorted = copySorted(arr);

	alert(sorted); // CSS, HTML, JavaScript
	alert(arr); // HTML, JavaScript, CSS (no changes)*/

	/*function Calculator() {
		
		//1. this에 calcuate 메서드를 추가하여 로직 만들기
		//문자열 한 개를 전달받는 메서드
		this.calculate = function(str) {


		//메서드 구현
		//2. split 메서드를 이용해서 "3", "+", "7"로 나누기
		//split/join – 문자열을 배열로, 배열을 문자열로 변환함
		let arr = str.split(" ");

		//3. parseInt(n) 함수 이용해서 배열에 저장된 숫자 문자열을 숫자로 바꾸기
		let o1 = parseInt(arr[0]);	//0 = 3, 1 = +, 2 = 7
		let o2 = parseInt(arr[2]);	//1은 +라서 안댐
		
		//4. 분기문 이용해서 +, - 처리하도록 하기
		if(arr[1] == "+") return o1 + o2;
		else if(arr[1] === "-") return o1 - o2;
		else {
			return this.operators[arr[1]](o1, o2);
		}
		}

		this.operators = {};	//빈 객체를 오퍼레이터스에 저장
		this.addMethod = function(operators, func) {	//키에 대입한 연산자 저장
			this.operators[operator] = func;
		}

	}

	let calc = new Calculator();
	alert( calc.calculate("3 + 7") );	//10
	alert( calc.calculate("7 - 3") );	//4
	calc.addMethod("*", (a, b) => a * b);
	calc.addMethod("/", (a, b) => a / b);
	calc.addMethod("**", (a, b) => a ** b);

	let result = calc.calculate("2 ** 3");
	alert( result );*/

	/*let john = { name: "John", surname: "Smith", id: 1 };
	let pete = { name: "Pete", surname: "Hunt", id: 2 };
	let mary = { name: "Mary", surname: "Key", id: 3 };

	let users = [ john, pete, mary ];

	usersMapped = users.map(u => ({ id: u.id, fullName: u.name + " " + u.sername}))
	/*
	usersMapped = [
	  { fullName: "John Smith", id: 1 },
	  { fullName: "Pete Hunt", id: 2 },
	  { fullName: "Mary Key", id: 3 }
	]
	

	alert( usersMapped[0].id ) // 1
	alert( usersMapped[0].fullName ) // John Smith*/

	

</script>